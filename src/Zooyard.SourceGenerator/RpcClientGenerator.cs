using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System.Text;

namespace Zooyard.SourceGenerator;

/// <summary>
///  The generator of Rpc client
/// </summary>
[Generator(LanguageNames.CSharp)]
public class RpcClientGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // 收集所有带有属性的接口声明
        var interfaceDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => s is InterfaceDeclarationSyntax ids && ids.AttributeLists.Count > 0,
                transform: static (ctx, _) => (InterfaceDeclarationSyntax)ctx.Node
            )
            .Where(static ids => ids != null);

        // 收集 Compilation
        var compilationProvider = context.CompilationProvider;

        // 组合接口和 Compilation
        var interfaceWithCompilation = interfaceDeclarations
            .Combine(compilationProvider);

        context.RegisterSourceOutput(interfaceWithCompilation, (spc, tuple) =>
        {
            var @interface = tuple.Left;
            var compilation = tuple.Right;

            var model = compilation.GetSemanticModel(@interface.SyntaxTree);
            if (model.GetDeclaredSymbol(@interface) is not INamedTypeSymbol symbol) return;
            if (!symbol.GetAttributes().Any(ad =>
                    ad.AttributeClass?.BaseType?.ToDisplayString() == "Zooyard.Attributes.ZooyardAttribute")) return;

            var rpcAttribute = symbol.GetAttributes().FirstOrDefault(ad =>
                ad.AttributeClass?.BaseType?.ToDisplayString() == "Zooyard.Attributes.ZooyardAttribute");

            if (rpcAttribute == null) return;

            var generateClient = (bool?)rpcAttribute
                .NamedArguments
                .FirstOrDefault(kvp => kvp.Key == "GenerateClient").Value.Value ?? true;
            var generateDependencyInjection = (bool?)rpcAttribute
                .NamedArguments
                .FirstOrDefault(kvp => kvp.Key == "GenerateDependencyInjection").Value.Value ?? true;

            // Skip if both are false
            if (!generateClient && !generateDependencyInjection) return;

            var serviceName = (string?)rpcAttribute.ConstructorArguments.FirstOrDefault().Value;

            var className = symbol.Name.Substring(1) + "Client"; // Changed the class name
            var interfaceName = symbol.Name;

            var symbolNamespace = symbol.ContainingNamespace.ToDisplayString();

            var modelCollector = new ModelCollector();
            modelCollector.Visit(@interface.SyntaxTree.GetRoot());
            var usingList = GenerateUsing(modelCollector);

            var stringBuilder = new StringBuilder();

            stringBuilder.AppendLine("// <auto-generated/>");
            foreach (var usingStr in usingList)
            {
                stringBuilder.AppendLine(usingStr);
            }
            stringBuilder.AppendLine();
            stringBuilder.AppendLine($"namespace {symbolNamespace}");
            stringBuilder.AppendLine("{");
            stringBuilder.AppendLine($"   public class {className} : ProxyExecutor, {interfaceName}");
            stringBuilder.AppendLine("   {");
            stringBuilder.AppendLine("         private readonly InterfaceMapping _interfaceMapping;");
            stringBuilder.AppendLine("         private readonly ZooyardInvoker _invoker;");
            stringBuilder.AppendLine("         private readonly Type _declaringType;");
            stringBuilder.AppendLine();
            stringBuilder.AppendLine($"         public {className}(ILogger<{interfaceName}> logger, IServiceProvider serviceProvider)");
            stringBuilder.AppendLine("         {");
            stringBuilder.AppendLine($"             _declaringType = typeof({interfaceName});");
            stringBuilder.AppendLine("             var zooyardAttr = _declaringType.GetCustomAttribute<ZooyardAttribute>();");
            stringBuilder.AppendLine("             _invoker = new ZooyardInvoker(logger, serviceProvider, zooyardAttr);");
            stringBuilder.AppendLine("             _interfaceMapping = this.GetType().GetInterfaceMap(_declaringType);");
            stringBuilder.AppendLine("         }");

            // Assume all methods return Task or Task<T>
            foreach (var member in symbol.GetMembers().OfType<IMethodSymbol>())
            {
                var parameterTypes = string.Join(", ", member.Parameters.Select(p => $"typeof({p.Type})"));
                var parameters = string.Join(", ", member.Parameters.Select(p => $"{p.Type} {p.Name}"));
                var callParameters = string.Join(",", member.Parameters.Select(p => p.Name));
                var methodName = member.Name;

                var returnType = GetReturnType(member.ReturnType.ToString()); // Changed the return type

                string GetReturnType(string returnType)
                {
                    if (returnType == "void")
                    {
                        return "void";
                    }
                    else if (returnType.StartsWith("System.Threading.Tasks.Task"))
                    {
                        if (returnType == "System.Threading.Tasks.Task")
                        {
                            return "async Task";
                        }
                        else
                        {
                            return $"async Task<{GetTypeArguments(((INamedTypeSymbol)member.ReturnType).TypeArguments[0])}>";
                        }
                    }
                    else
                    {
                        return member.ReturnType.ToString();
                    }
                }

                var invokeAsync = GetInvoke(member.ReturnType.ToString()); // Changed the return type
                string GetInvoke(string returnType)
                {
                    if (returnType == "void")
                    {
                        return "_invoker.Invoke";
                    }
                    else if (returnType.StartsWith("System.Threading.Tasks.Task"))
                    {
                        if (returnType == "System.Threading.Tasks.Task")
                        {
                            return "await _invoker.InvokeAsync";
                        }
                        else
                        {
                            return $"return await _invoker.InvokeAsync<{GetTypeArguments(((INamedTypeSymbol)member.ReturnType).TypeArguments[0])}>";
                        }
                    }
                    else
                    {
                        return $"return _invoker.Invoke<{member.ReturnType}>";
                    }
                }
                string GetTypeArguments(ITypeSymbol returnType)
                {
                    if (returnType is not INamedTypeSymbol namedType)
                    {
                        return "";
                    }

                    if (namedType.TypeArguments.Length == 0)
                    {
                        return namedType.Name;
                    }

                    var argStr = "<";
                    foreach (var arg in namedType.TypeArguments)
                    {
                        var argInner = GetTypeArguments(arg);
                        if (string.IsNullOrWhiteSpace(argInner))
                        {
                            continue;
                        }
                        argStr += argInner;
                        argStr += ", ";
                    }
                    if (argStr.Length > 1)
                    {
                        argStr = argStr.Substring(0, argStr.Length - 2);
                    }
                    argStr += ">";
                    return namedType.Name + argStr;
                }
                stringBuilder.AppendLine();
                stringBuilder.AppendLine("        [ZooyardImpl]");
                stringBuilder.AppendLine($"        public {returnType} {methodName}({parameters})");
                stringBuilder.AppendLine("        {");
                stringBuilder.AppendLine($"             var method = this.GetType().GetMethod(nameof({methodName}), new Type[] {{{parameterTypes}}});");
                stringBuilder.AppendLine("             var (mi, mtoken) = _invoker.GetInterfaceMethodBase(method, _interfaceMapping);");
                stringBuilder.AppendLine($"             object[] args = [{callParameters}];");
                stringBuilder.AppendLine("             var context = _invoker.GetMethodResolverContext(this, _declaringType, mi, mtoken, args);");
                stringBuilder.AppendLine($"             {invokeAsync}(context);");
                stringBuilder.AppendLine("        ");
                stringBuilder.AppendLine("        }");
            }

            stringBuilder.AppendLine("    }");
            stringBuilder.AppendLine("}");

            spc.AddSource($"{className}.g.cs", SourceText.From(stringBuilder.ToString(), Encoding.UTF8));
        });
    }

    private List<string> GenerateUsing(ModelCollector typeSymbol)
    {
        var result = new[]{
                    "using Microsoft.Extensions.Logging;",
                    "using System.Diagnostics;",
                    "using System.Reflection;",
                    "using System.Runtime.CompilerServices;",
                    "using System.Threading.Tasks;",
                    "using System.Threading;",
                    "using System;",
                    "using Zooyard;",
                    "using Zooyard.Attributes;",
                    "using Zooyard.DynamicProxy;",
                    "using Zooyard.Rpc;"
        };

        return result.Concat(typeSymbol.UsingDirectiveList).Distinct().OrderBy(w => w).ToList();
    }
    private class ModelCollector : CSharpSyntaxWalker
    {
        public List<string> UsingDirectiveList { get; set; } = new();
        public override void VisitUsingDirective(UsingDirectiveSyntax node)
        {
            if (node.Name != null)
            {
                UsingDirectiveList.Add("using " + node.Name.ToFullString() + ";");
            }
            base.VisitUsingDirective(node);
        }
    }
}